C51 COMPILER V9.56.0.0   MAIN                                                              08/05/2024 10:34:42 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: E:\Keil_c51v956\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE INCDIR(.\Device;.\System) DEBUG OBJ
                    -ECTEXTEND PRINT(.\Listings\main.lst) OBJECT(.\Objects\main.obj)

line level    source

   1          #include "System.h"
   2          u8 key_time;
   3          u8 Display = 0;
   4          u8 adc_val;
   5          u16 adc_time;
   6          
   7          u8 pwm_time;
   8          u8 pwm_duty;
   9          
  10          u8 twinkling_flag;
  11          u16 twinkling_time;
  12          u8 i = 0;
  13          bit twinkling;
  14          
  15          u8 kbd_six_count=0;
  16          
  17          u8 a;
  18          
  19          void Timer2_Init(void)          //1毫秒@12.000MHz
  20          {
  21   1              AUXR &= 0xFB;                   //定时器时钟12T模式
  22   1              T2L = 0x18;                             //设置定时初始值
  23   1              T2H = 0xFC;                             //设置定时初始值
  24   1              AUXR |= 0x10;                   //定时器2开始计时
  25   1      //----------记得要加上这两个------------------
  26   1              IE2 |= 0x04;                                                     //开定时器2中断
  27   1              EA = 1;                                                                                                                  //开启总中断
  28   1      }
  29          
  30          //ADC读取
  31          void ADC_Read_Process(){
  32   1              if(adc_time >=500){
  33   2                      adc_time =0;
  34   2                      adc_val = Read_ADC(0x43)/51;         //读取PCF8591 设定为0~5v
  35   2              }
  36   1      
  37   1      }
  38          
  39          u16 LED_Interval;
  40          u16 LED_Intervaltime[4];
  41          u8 LED_Mode=1;
  42          u8 ledshift;
  43          u8 led_ctrl = 0xff;
  44          bit LED_flag=1;
  45          //LED灯状态
  46          void LED_Process(){
  47   1              if(LED_flag==1){
  48   2                      if(LED_Mode==1){
  49   3                              if(LED_Interval>=LED_Intervaltime[i]){
  50   4                                      led_ctrl =  ~(0x01<<ledshift);
  51   4                                      ledshift++;
  52   4                                      if(ledshift==8) ledshift=0;
  53   4                                      LED_Interval=0;
  54   4                              }
C51 COMPILER V9.56.0.0   MAIN                                                              08/05/2024 10:34:42 PAGE 2   

  55   3                      }
  56   2                      if(LED_Mode==2){
  57   3                              if(LED_Interval>=LED_Intervaltime[i]){
  58   4                                      led_ctrl = ~(0x80 >>ledshift);
  59   4                                      ledshift++;
  60   4                                      if(ledshift==8) ledshift=0;
  61   4                                      LED_Interval=0;
  62   4                              }
  63   3                      }
  64   2                      if(LED_Mode==3){
  65   3                              if(LED_Interval>=LED_Intervaltime[i]){
  66   4                                      led_ctrl = ~((0x01<<ledshift) | (0x80>>ledshift));
  67   4                                      ledshift++;
  68   4                                      if(ledshift==4) ledshift=0;
  69   4                                      LED_Interval=0;
  70   4                              }
  71   3                      }
  72   2                      if(LED_Mode==4){
  73   3                              if(LED_Interval>=LED_Intervaltime[i]){
  74   4                                      led_ctrl = ~((0x08>>ledshift) | (0x10<<ledshift));
  75   4                                      ledshift++;
  76   4                                      if(ledshift==4) ledshift=0;
  77   4                                      LED_Interval=0;
  78   4                              }
  79   3                      }
  80   2              
  81   2              }
  82   1              Device_Ctrl(0x80,led_ctrl);
  83   1      }
  84          
  85          //PWM调光
  86          void PWM_Process(u8 adc_val){
  87   1              if(0<=adc_val && adc_val<=1) pwm_duty = 20;
  88   1              if(1<adc_val && adc_val<=2) pwm_duty = 40;
  89   1              if(2<adc_val && adc_val<=3) pwm_duty = 60;
  90   1              if(3<adc_val && adc_val<=5) pwm_duty = 80;
  91   1              pwm_time = pwm_time%10 +1;
  92   1              if(pwm_time <= (pwm_duty/10)){
  93   2                      Device_Ctrl(0x80,led_ctrl);
  94   2              }
  95   1              else{
  96   2                      Device_Ctrl(0x80,0xff);
  97   2              }
  98   1      }
  99          
 100          //读取EEPROM      第一次开机时用
 101          void RRead_EEPROM(){
 102   1              if(Read_EEPROM(0x05) != 0xff && Read_EEPROM(0x06) != 0xff){                                                     //如果里面没有数据就不读取了
 103   2                      LED_Intervaltime[0] = (Read_EEPROM(0x01)<<8) | Read_EEPROM(0x00);
 104   2                      LED_Intervaltime[1] = (Read_EEPROM(0x03)<<8) | Read_EEPROM(0x02);
 105   2                      LED_Intervaltime[2] = (Read_EEPROM(0x05)<<8) | Read_EEPROM(0x04);
 106   2                      LED_Intervaltime[3] = (Read_EEPROM(0x07)<<8) | Read_EEPROM(0x06);
 107   2              }
 108   1              else{
 109   2                      LED_Intervaltime[0] = 400;
 110   2                      LED_Intervaltime[1] = 400;
 111   2                      LED_Intervaltime[2] = 400;
 112   2                      LED_Intervaltime[3] = 400;
 113   2              }
 114   1      }
 115          
 116          
C51 COMPILER V9.56.0.0   MAIN                                                              08/05/2024 10:34:42 PAGE 3   

 117          
 118          //数码管函数
 119          u8 key_value;
 120          void SMG_Process(){
 121   1              if(Display==0){
 122   2              amg_buf[0] = smg_code[LED_Intervaltime[0]/1000];
 123   2              amg_buf[1] = smg_code[LED_Intervaltime[0]/100%10];
 124   2              amg_buf[2] = smg_code[LED_Intervaltime[0]/10%10];
 125   2              amg_buf[3] = smg_code[LED_Intervaltime[0]%10];
 126   2              amg_buf[4] =0x00;
 127   2              amg_buf[5] = 0x00;
 128   2              amg_buf[6] =0x00;
 129   2              amg_buf[7] = smg_code[a];
 130   2              }
 131   1              
 132   1              if(Display==1){
 133   2              if(twinkling_flag==1){                                  //闪烁
 134   3                      if(twinkling_time>=800){twinkling =~ twinkling;twinkling_time=0;}
 135   3                      if(twinkling==0){
 136   4                      amg_buf[0] = smg_code[0];
 137   4                      amg_buf[1] = smg_code[LED_Mode];
 138   4                      amg_buf[2] = smg_code[0];
 139   4                      }
 140   3                      if(twinkling==1){
 141   4                      amg_buf[0] =0x00;
 142   4                      amg_buf[1] =0x00;
 143   4                      amg_buf[2] = 0x00;
 144   4                      }
 145   3              }else{
 146   3              amg_buf[0] = smg_code[0];
 147   3              amg_buf[1] = smg_code[LED_Mode];
 148   3              amg_buf[2] = smg_code[0];
 149   3              }
 150   2      
 151   2              amg_buf[3] = 0x00;
 152   2              
 153   2              
 154   2                      if(twinkling_flag==2){                                  //闪烁
 155   3                      if(twinkling_time>=800){twinkling =~ twinkling;twinkling_time=0;}
 156   3                      if(twinkling==0){
 157   4                      amg_buf[4] =smg_code[LED_Intervaltime[i]/1000];
 158   4                      amg_buf[5] = smg_code[LED_Intervaltime[i]/100%10];
 159   4                      amg_buf[6] = smg_code[LED_Intervaltime[i]/10%10];
 160   4                      amg_buf[7] = smg_code[LED_Intervaltime[i]%10];
 161   4                      }
 162   3                      if(twinkling==1){
 163   4                      amg_buf[4] = 0x00;
 164   4                      amg_buf[5] =0x00;
 165   4                      amg_buf[6] =0x00;
 166   4                      amg_buf[7] = 0x00;
 167   4                      }
 168   3              }else{
 169   3              amg_buf[4] =smg_code[LED_Intervaltime[i]/1000];
 170   3              amg_buf[5] = smg_code[LED_Intervaltime[i]/100%10];
 171   3              amg_buf[6] = smg_code[LED_Intervaltime[i]/10%10];
 172   3              amg_buf[7] = smg_code[LED_Intervaltime[i]%10];
 173   3              }
 174   2              
 175   2              }
 176   1              
 177   1              if(Display==2){
 178   2              amg_buf[0] = 0x00;
C51 COMPILER V9.56.0.0   MAIN                                                              08/05/2024 10:34:42 PAGE 4   

 179   2              amg_buf[1] = 0x00;
 180   2              amg_buf[2] = 0x00;
 181   2              amg_buf[3] = 0x00;
 182   2              amg_buf[4] = 0x00;
 183   2              amg_buf[5] = 0x00;
 184   2              amg_buf[6] = smg_code[0];
 185   2              amg_buf[7] = smg_code[5];
 186   2              }
 187   1              
 188   1      }
 189          
 190          u8 key_io;
 191          
 192          void main(){
 193   1              System_Init();
 194   1              Timer2_Init();
 195   1              RRead_EEPROM();
 196   1              //Write_EEPROM(0x01,0x90>>8);
 197   1              while(1){
 198   2              
 199   2              SMG_Process();
 200   2              ADC_Read_Process();
 201   2                      if(key_time>=50){
 202   3                              key_time=0;
 203   3                              KBD_ThreeLine();
 204   3                              if(Trg_KBD==0x81){                      //7      LED灯启动停止按键
 205   4                                      LED_flag =~ LED_flag;
 206   4                              }
 207   3                              if(Trg_KBD==0x82){             //6      设置按键
 208   4                                      kbd_six_count++;
 209   4                                      if(kbd_six_count==1){Display=1;}
 210   4                                      if(kbd_six_count==2){twinkling_flag=1;}
 211   4                                      if(kbd_six_count==3){twinkling_flag=2;}
 212   4                                      if(kbd_six_count==4){
 213   5                                      twinkling_flag=0;kbd_six_count=0;Display=0;                                             //退出设置模式时要保存EEPROM
 214   5                                      Write_EEPROM(0x00,LED_Intervaltime[0]);
 215   5                                      Write_EEPROM(0x01,LED_Intervaltime[0]>>8);
 216   5                                      Write_EEPROM(0x02,LED_Intervaltime[1]);
 217   5                                      Write_EEPROM(0x03,LED_Intervaltime[1]>>8);
 218   5                                      Write_EEPROM(0x04,LED_Intervaltime[2]);
 219   5                                      Write_EEPROM(0x05,LED_Intervaltime[2]>>8);
 220   5                                      Write_EEPROM(0x06,LED_Intervaltime[3]);
 221   5                                      Write_EEPROM(0x07,LED_Intervaltime[3]>>8);                              
 222   5                                      }
 223   4                              }
 224   3                              if(twinkling_flag==1){
 225   4                                      if(Trg_KBD==0x84){      
 226   5                                              LED_Mode++;
 227   5                                              i++;                               //这个是LED_Intervaltime[i] ,保证每一个Mode对应一个时间
 228   5                                              ledshift=0;
 229   5                                              Device_Ctrl(0x80,0xff);
 230   5                                              if(LED_Mode==5) {LED_Mode=1;i=0; }          
 231   5                                      }
 232   4                                      if(Trg_KBD==0x88){
 233   5                                              if(LED_Mode>0){
 234   6                                                      LED_Mode--;
 235   6                                                      i--;
 236   6                                                      ledshift=0;
 237   6                                                      Device_Ctrl(0x80,0xff);
 238   6                                              }
 239   5                                      }
 240   4                              }
C51 COMPILER V9.56.0.0   MAIN                                                              08/05/2024 10:34:42 PAGE 5   

 241   3                              if(twinkling_flag==2){
 242   4                                      if(Trg_KBD==0x84){      
 243   5                                              LED_Intervaltime[i] += 100;
 244   5                                              if(LED_Intervaltime[i]==1500) LED_Intervaltime[i]=400;
 245   5                                      }
 246   4                                      if(Trg_KBD==0x88){
 247   5                                              if(LED_Intervaltime[i]>400){
 248   6                                                      LED_Intervaltime[i] -= 100;                     
 249   6                                              }
 250   5                                      }
 251   4                              }
 252   3                              
 253   3                              if(Cont_KBD==0x88){
 254   4                                      if(kbd_six_count==0)Display=2;
 255   4                              }
 256   3                              if(Cont_KBD==0){
 257   4                                      if(kbd_six_count==0)Display=0;
 258   4                              }
 259   3                      }
 260   2                      
 261   2                      
 262   2                      
 263   2                      
 264   2              }
 265   1      }
 266          
 267          
 268          void Timer2_ISR()interrupt 12{
 269   1              SMG_Display();
 270   1              key_time++;
 271   1              adc_time++;
 272   1              LED_Interval++;
 273   1              pwm_time++;
 274   1              LED_Process();
 275   1              PWM_Process(adc_val);
 276   1              twinkling_time++;
 277   1              
 278   1              
 279   1              
 280   1              
 281   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1535    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     28    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      2    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
